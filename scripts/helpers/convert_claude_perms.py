import json
import os
import sys
import re

def parse_bash_cmd(pattern):
    # Pattern: Bash(cmd:*)
    # We want 'cmd'
    m = re.match(r"Bash\((.+):\*\)", pattern)
    if m:
        return m.group(1)
    return None

def parse_read_path(pattern):
    # Pattern: Read(glob)
    # Claude uses glob syntax, often starting with // or /
    m = re.match(r"Read\((.+)\)", pattern)
    if m:
        return m.group(1)
    return None

def parse_webfetch_domain(pattern):
    m = re.match(r"WebFetch\(domain:(.+)\)", pattern)
    if m:
        return m.group(1)
    return None

def convert_to_toml(settings_path):
    try:
        with open(settings_path, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"# Settings file not found: {settings_path}")
        return
    except json.JSONDecodeError:
        print(f"# Error decoding JSON: {settings_path}")
        return

    perms = data.get("permissions", {})
    
    print("# ========================================================")
    print("# AUTO-GENERATED POLICY FROM CLAUDE CODE SETTINGS")
    print(f"# Source: {settings_path}")
    print("# Generated by: scripts/helpers/convert_claude_perms.py")
    print("# ========================================================")
    print("")

    categories = [
        ("allow", "allow", 100),
        ("deny", "deny", 900),
        ("ask", "ask_user", 100)
    ]

    for source_key, decision, priority in categories:
        items = perms.get(source_key, [])
        for item in items:
            rule = None
            
            if item.startswith("Bash("):
                cmd = parse_bash_cmd(item)
                if cmd:
                    rule = {
                        "toolName": "run_shell_command",
                        "commandPrefix": cmd,
                        "decision": decision,
                        "priority": priority
                    }
            elif item == "WebSearch":
                rule = {
                    "toolName": "google_web_search",
                    "decision": decision,
                    "priority": priority
                }
            elif item == "WebFetch":
                rule = {
                    "toolName": "web_fetch",
                    "decision": decision,
                    "priority": priority
                }
            elif item.startswith("WebFetch(domain:"):
                domain = parse_webfetch_domain(item)
                if domain:
                    # Regex to match the domain in the prompt args
                    # This is a heuristic
                    rule = {
                        "toolName": "web_fetch",
                        "argsPattern": f".*{re.escape(domain)}.*", 
                        "decision": decision,
                        "priority": priority
                    }
            elif item == "Read":
                rule = {
                    "toolName": "read_file",
                    "decision": decision,
                    "priority": priority
                }
            elif item.startswith("Read("):
                path_glob = parse_read_path(item)
                if path_glob:
                    # Convert glob to regex
                    # remove leading // if present for cleaner regex? Claude uses // for project root sometimes?
                    # or just handle *
                    regex = path_glob.replace(".", r"\.").replace("*", ".*")
                    rule = {
                        "toolName": "read_file",
                        "argsPattern": regex,
                        "decision": decision,
                        "priority": priority
                    }

            if rule:
                print("[[rule]]")
                for k, v in rule.items():
                    if isinstance(v, str):
                        print(f'{k} = "{v}"')
                    else:
                        print(f'{k} = {v}')
                print("")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("# Usage: python convert.py <settings_json_path>")
        sys.exit(1)
    
    convert_to_toml(sys.argv[1])
