import argparse
import json
import sys
import re
import shlex

def parse_bash_cmd(pattern):
    # Pattern: Bash(cmd:*)
    # We want 'cmd'
    m = re.match(r"Bash\((.+?)(?::\*)?\)$", pattern)
    if m:
        return m.group(1).strip()
    return None

def parse_read_path(pattern):
    # Pattern: Read(glob)
    # Claude uses glob syntax, often starting with // or /
    m = re.match(r"Read\((.+)\)", pattern)
    if m:
        return m.group(1)
    return None

def parse_webfetch_domain(pattern):
    m = re.match(r"WebFetch\(domain:(.+)\)", pattern)
    if m:
        return m.group(1)
    return None

def escape_rules_string(value):
    return value.replace("\\", "\\\\").replace("\"", "\\\"")

def strip_env_assignments(tokens):
    env_re = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*=.*")
    i = 0
    while i < len(tokens) and env_re.match(tokens[i]):
        i += 1
    return tokens[i:]

def bash_cmd_to_tokens(cmd):
    try:
        tokens = shlex.split(cmd, posix=True)
    except ValueError:
        return None
    tokens = strip_env_assignments(tokens)
    if not tokens:
        return None
    return tokens

def load_settings(settings_path):
    try:
        with open(settings_path, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"# Settings file not found: {settings_path}")
        return None
    except json.JSONDecodeError:
        print(f"# Error decoding JSON: {settings_path}")
        return None
    return data

def convert_to_toml(settings_path, data):
    if data is None:
        return

    perms = data.get("permissions", {})
    
    print("# ========================================================")
    print("# AUTO-GENERATED POLICY FROM CLAUDE CODE SETTINGS")
    print(f"# Source: {settings_path}")
    print("# Generated by: scripts/helpers/convert_claude_perms.py")
    print("# ========================================================")
    print("")

    categories = [
        ("allow", "allow", 100),
        ("deny", "deny", 900),
        ("ask", "ask_user", 100)
    ]

    for source_key, decision, priority in categories:
        items = perms.get(source_key, [])
        for item in items:
            rule = None
            
            if item.startswith("Bash("):
                cmd = parse_bash_cmd(item)
                if cmd:
                    rule = {
                        "toolName": "run_shell_command",
                        "commandPrefix": cmd,
                        "decision": decision,
                        "priority": priority
                    }
            elif item == "WebSearch":
                rule = {
                    "toolName": "google_web_search",
                    "decision": decision,
                    "priority": priority
                }
            elif item == "WebFetch":
                rule = {
                    "toolName": "web_fetch",
                    "decision": decision,
                    "priority": priority
                }
            elif item.startswith("WebFetch(domain:"):
                domain = parse_webfetch_domain(item)
                if domain:
                    # Regex to match the domain in the prompt args
                    # This is a heuristic
                    rule = {
                        "toolName": "web_fetch",
                        "argsPattern": f".*{re.escape(domain)}.*", 
                        "decision": decision,
                        "priority": priority
                    }
            elif item == "Read":
                rule = {
                    "toolName": "read_file",
                    "decision": decision,
                    "priority": priority
                }
            elif item.startswith("Read("):
                path_glob = parse_read_path(item)
                if path_glob:
                    # Convert glob to regex
                    # remove leading // if present for cleaner regex? Claude uses // for project root sometimes?
                    # or just handle *
                    regex = path_glob.replace(".", r"\.").replace("*", ".*")
                    rule = {
                        "toolName": "read_file",
                        "argsPattern": regex,
                        "decision": decision,
                        "priority": priority
                    }

            if rule:
                print("[[rule]]")
                for k, v in rule.items():
                    if isinstance(v, str):
                        print(f'{k} = "{v}"')
                    else:
                        print(f'{k} = {v}')
                print("")

def convert_to_codex_rules(settings_path, data):
    if data is None:
        return

    perms = data.get("permissions", {})

    decision_map = {
        "allow": "allow",
        "deny": "forbidden",
        "ask": "prompt"
    }

    print("# ========================================================")
    print("# AUTO-GENERATED CODEX RULES FROM CLAUDE CODE SETTINGS")
    print(f"# Source: {settings_path}")
    print("# Generated by: scripts/helpers/convert_claude_perms.py")
    print("# NOTE: claude_sync.generated.rules is a build artifact; safe to delete and will be regenerated by scripts/sync_claude_to_codex.sh")
    print("# NOTE: 'ask' entries map to decision=\"prompt\"")
    print("# Test: codex execpolicy check --rules ~/.codex/rules/default.rules -- <command>")
    print("# ========================================================")
    print("")

    for source_key in ["allow", "deny", "ask"]:
        items = perms.get(source_key, [])
        decision = decision_map[source_key]

        if items:
            print(f"# {source_key} rules")

        for item in items:
            if item.startswith("Bash("):
                cmd = parse_bash_cmd(item)
                if cmd:
                    cmd_escaped = escape_rules_string(cmd)
                    print(
                        f'prefix_rule(pattern=["bash", "-lc", "{cmd_escaped}"], decision="{decision}")'
                    )
                    tokens = bash_cmd_to_tokens(cmd)
                    if tokens:
                        tokens_escaped = [f'"{escape_rules_string(token)}"' for token in tokens]
                        print(
                            f'prefix_rule(pattern=[{", ".join(tokens_escaped)}], decision="{decision}")'
                        )
                else:
                    print(f"# Skipped unparsable Bash permission ({source_key}): {item}")
            else:
                print(f"# Skipped non-Bash permission ({source_key}): {item}")

        if items:
            print("")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert Claude Code permissions into policy formats."
    )
    parser.add_argument("settings_path", help="Path to Claude settings.json")
    parser.add_argument(
        "--format",
        choices=["gemini", "codex"],
        default="gemini",
        help="Output format (default: gemini)",
    )
    args = parser.parse_args()

    settings = load_settings(args.settings_path)

    if args.format == "codex":
        convert_to_codex_rules(args.settings_path, settings)
    else:
        convert_to_toml(args.settings_path, settings)
