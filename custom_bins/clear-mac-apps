#!/usr/bin/env zsh
# Clear Mac Apps - Manage running apps with configurable behavior
# Used by macOS Shortcuts via "Run Shell Script" action
#
# Config file supports three sections:
#   [no-touch]      - Apps to leave completely alone
#   [close-windows] - Apps where we close windows but don't quit
#   [slow-close]    - Apps needing extra time for cleanup (backup, sync)

set -euo pipefail

SCRIPT_DIR="${0:A:h}"
CONFIG_FILE="${SCRIPT_DIR}/../config/clear_mac_apps.conf"
DRY_RUN=false

# Parse flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|-n)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            echo "Usage: clear-mac-apps [--dry-run|-n]"
            echo "  --dry-run, -n  Show what would happen without making changes"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Parse apps from a specific section in config
# Usage: get_apps_in_section "no-touch"
get_apps_in_section() {
    local section="$1"
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "Error: Config file not found: $CONFIG_FILE" >&2
        exit 1
    fi
    awk -v section="[$section]" '
        /^\[.*\]$/ { in_section = ($0 == section); next }
        in_section && !/^#/ && !/^[[:space:]]*$/ {
            gsub(/^[[:space:]]+|[[:space:]]+$/, "")
            if (length > 0) print
        }
    ' "$CONFIG_FILE"
}

# Get list of running GUI apps (one per line)
get_running_apps() {
    osascript -e 'tell application "System Events"
        set appList to name of every process whose background only is false
        set output to ""
        repeat with appName in appList
            set output to output & appName & linefeed
        end repeat
        return output
    end tell'
}

# Quit an app gracefully
quit_app() {
    local app="$1"
    osascript -e "tell application \"$app\" to quit" 2>/dev/null || true
}

# Close all windows of an app without quitting
# Usage: close_app_windows "AppName" [patience]
#   patience: number of no-progress attempts before giving up (default: 3)
close_app_windows() {
    local app="$1"
    local patience="${2:-3}"
    # Use Cmd+W via System Events - works for Electron apps and others
    # that don't respond to standard AppleScript window commands
    # Includes timeout protection: max 20 attempts, exits if no progress
    osascript -e "
        tell application \"System Events\"
            tell process \"$app\"
                set frontmost to true
                set maxAttempts to 20
                set attempts to 0
                set lastCount to count of windows
                set stuckCount to 0
                set maxStuck to $patience
                repeat while (count of windows) > 0 and attempts < maxAttempts
                    keystroke \"w\" using command down
                    delay 0.2
                    set attempts to attempts + 1
                    set currentCount to count of windows
                    if currentCount >= lastCount then
                        set stuckCount to stuckCount + 1
                        if stuckCount >= maxStuck then
                            -- No progress after maxStuck attempts, app is stuck
                            exit repeat
                        end if
                    else
                        set stuckCount to 0
                    end if
                    set lastCount to currentCount
                end repeat
            end tell
        end tell
    " 2>/dev/null || true
}

main() {
    # Build associative arrays for O(1) lookup (keys are lowercase)
    typeset -A no_touch_set
    typeset -A close_windows_set
    typeset -A slow_close_set

    while IFS= read -r app; do
        [[ -n "$app" ]] && no_touch_set[${(L)app}]=1
    done < <(get_apps_in_section "no-touch")

    while IFS= read -r app; do
        [[ -n "$app" ]] && close_windows_set[${(L)app}]=1
    done < <(get_apps_in_section "close-windows")

    while IFS= read -r app; do
        [[ -n "$app" ]] && slow_close_set[${(L)app}]=1
    done < <(get_apps_in_section "slow-close")

    # Get running apps
    local -a running_apps=()
    while IFS= read -r app; do
        [[ -n "$app" ]] && running_apps+=("$app")
    done < <(get_running_apps)

    # Separate apps by action type
    local -a apps_to_quit=()
    local -a apps_close_windows=()
    local -a apps_slow_close=()

    for app in "${running_apps[@]}"; do
        local app_lower="${(L)app}"

        if (( ${+no_touch_set[$app_lower]} )); then
            continue
        elif (( ${+slow_close_set[$app_lower]} )); then
            apps_slow_close+=("$app")
        elif (( ${+close_windows_set[$app_lower]} )); then
            apps_close_windows+=("$app")
        else
            apps_to_quit+=("$app")
        fi
    done

    # Dry-run mode: just show what would happen
    if $DRY_RUN; then
        echo "=== DRY RUN ==="
        echo ""
        echo "Would QUIT (${#apps_to_quit}):"
        for app in "${apps_to_quit[@]}"; do
            echo "  - $app"
        done
        echo ""
        echo "Would CLOSE WINDOWS (${#apps_close_windows}):"
        for app in "${apps_close_windows[@]}"; do
            echo "  - $app"
        done
        echo ""
        echo "Would SLOW-CLOSE (${#apps_slow_close}):"
        for app in "${apps_slow_close[@]}"; do
            echo "  - $app"
        done
        echo ""
        echo "Would SKIP (no-touch):"
        for app in "${running_apps[@]}"; do
            local app_lower="${(L)app}"
            if (( ${+no_touch_set[$app_lower]} )); then
                echo "  - $app"
            fi
        done
        return 0
    fi

    # Quit apps in parallel (don't need focus)
    if (( ${#apps_to_quit} > 0 )); then
        echo "Quitting ${#apps_to_quit} apps in parallel..."
        for app in "${apps_to_quit[@]}"; do
            quit_app "$app" &
        done
        wait
    fi

    # Close windows sequentially (need focus for Cmd+W)
    for app in "${apps_close_windows[@]}"; do
        echo "Closing windows: $app"
        close_app_windows "$app" 3
    done

    # Slow-close apps sequentially with more patience
    for app in "${apps_slow_close[@]}"; do
        echo "Closing windows (slow): $app"
        close_app_windows "$app" 10
    done

    echo ""
    echo "Done."
    (( ${#no_touch_set} > 0 )) && echo "  No-touch: ${(k)no_touch_set}"
    (( ${#close_windows_set} > 0 )) && echo "  Close-windows: ${(k)close_windows_set}"
    (( ${#slow_close_set} > 0 )) && echo "  Slow-close: ${(k)slow_close_set}"
}

main "$@"
