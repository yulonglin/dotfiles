#!/usr/bin/env zsh
# Clear Mac Apps - Manage running apps with configurable behavior
# Used by macOS Shortcuts via "Run Shell Script" action
#
# Config file supports three sections:
#   [no-touch]      - Apps to leave completely alone
#   [close-windows] - Apps where we close windows but don't quit
#   [slow-close]    - Apps needing extra time for cleanup (backup, sync)

set -euo pipefail

SCRIPT_DIR="${0:A:h}"
CONFIG_FILE="${SCRIPT_DIR}/../config/clear_mac_apps.conf"
REGISTRY_FILE="${SCRIPT_DIR}/../config/safari_web_apps.local"
DRY_RUN=false

# Parse flags
while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|-n)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            echo "Usage: clear-mac-apps [--dry-run|-n]"
            echo "  --dry-run, -n  Show what would happen without making changes"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Parse apps from a specific section in config
# Usage: get_apps_in_section "no-touch"
get_apps_in_section() {
    local section="$1"
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "Error: Config file not found: $CONFIG_FILE" >&2
        exit 1
    fi
    awk -v section="[$section]" '
        /^\[.*\]$/ { in_section = ($0 == section); next }
        in_section && !/^#/ && !/^[[:space:]]*$/ {
            sub(/#.*/, "")
            gsub(/^[[:space:]]+|[[:space:]]+$/, "")
            if (length > 0) print
        }
    ' "$CONFIG_FILE"
}

# Get list of running GUI apps as "name|bundle_id" per line
get_running_apps() {
    osascript -e 'tell application "System Events"
        set procList to every process whose background only is false
        set output to ""
        repeat with proc in procList
            set procName to name of proc
            set procBID to bundle identifier of proc
            if procBID is missing value then set procBID to ""
            set output to output & procName & "|" & procBID & linefeed
        end repeat
        return output
    end tell'
}

# Quit an app gracefully
quit_app() {
    local app="$1"
    osascript -e "tell application \"$app\" to quit" 2>/dev/null || true
}

# Close all windows of an app without quitting
# Usage: close_app_windows "AppName" [patience]
#   patience: number of no-progress attempts before giving up (default: 3)
close_app_windows() {
    local app="$1"
    local patience="${2:-3}"
    # Use Cmd+W via System Events - works for Electron apps and others
    # that don't respond to standard AppleScript window commands
    # Includes timeout protection: max 20 attempts, exits if no progress
    osascript -e "
        tell application \"System Events\"
            tell process \"$app\"
                set frontmost to true
                set maxAttempts to 20
                set attempts to 0
                set lastCount to count of windows
                set stuckCount to 0
                set maxStuck to $patience
                repeat while (count of windows) > 0 and attempts < maxAttempts
                    keystroke \"w\" using command down
                    delay 0.2
                    set attempts to attempts + 1
                    set currentCount to count of windows
                    if currentCount >= lastCount then
                        set stuckCount to stuckCount + 1
                        if stuckCount >= maxStuck then
                            -- No progress after maxStuck attempts, app is stuck
                            exit repeat
                        end if
                    else
                        set stuckCount to 0
                    end if
                    set lastCount to currentCount
                end repeat
            end tell
        end tell
    " 2>/dev/null || true
}

main() {
    # Load Safari web app registry for bundle ID fallback matching
    typeset -A registry  # registry[lowercase_name] = bundle_id
    if [[ -f "$REGISTRY_FILE" ]]; then
        while IFS='|' read -r name bid _path; do
            [[ "$name" == \#* || -z "$name" ]] && continue
            registry[${(L)name}]="$bid"
        done < "$REGISTRY_FILE"
    fi

    # Build associative arrays for O(1) lookup (keys are lowercase)
    typeset -A no_touch_set
    typeset -A close_windows_set
    typeset -A slow_close_set

    while IFS= read -r app; do
        [[ -n "$app" ]] && no_touch_set[${(L)app}]=1
    done < <(get_apps_in_section "no-touch")

    while IFS= read -r app; do
        [[ -n "$app" ]] && close_windows_set[${(L)app}]=1
    done < <(get_apps_in_section "close-windows")

    while IFS= read -r app; do
        [[ -n "$app" ]] && slow_close_set[${(L)app}]=1
    done < <(get_apps_in_section "slow-close")

    # Build bundle ID sets for fallback matching (from registry)
    typeset -A no_touch_bids
    typeset -A close_windows_bids
    typeset -A slow_close_bids

    for name in ${(k)no_touch_set}; do
        [[ -n "${registry[$name]:-}" ]] && no_touch_bids[${registry[$name]}]=1
    done
    for name in ${(k)close_windows_set}; do
        [[ -n "${registry[$name]:-}" ]] && close_windows_bids[${registry[$name]}]=1
    done
    for name in ${(k)slow_close_set}; do
        [[ -n "${registry[$name]:-}" ]] && slow_close_bids[${registry[$name]}]=1
    done

    # Get running apps with bundle IDs (tab-separated: "name<TAB>bid")
    # Tab-separated to handle multiple processes with the same name (e.g. Safari web apps)
    local SEP=$'\t'
    local -a running_entries=()
    while IFS='|' read -r name bid; do
        [[ -n "$name" ]] || continue
        running_entries+=("${name}${SEP}${bid}")
    done < <(get_running_apps)

    # Classify: check name match first, bundle ID as fallback
    local -a apps_to_quit=()
    local -a apps_close_windows=()
    local -a apps_slow_close=()
    local -a apps_skipped=()

    for entry in "${running_entries[@]}"; do
        local app="${entry%%${SEP}*}"
        local bid="${entry#*${SEP}}"
        local app_lower="${(L)app}"

        if (( ${+no_touch_set[$app_lower]} )) || { [[ -n "$bid" ]] && (( ${+no_touch_bids[$bid]} )) }; then
            apps_skipped+=("$app")
        elif (( ${+slow_close_set[$app_lower]} )) || { [[ -n "$bid" ]] && (( ${+slow_close_bids[$bid]} )) }; then
            apps_slow_close+=("$app")
        elif (( ${+close_windows_set[$app_lower]} )) || { [[ -n "$bid" ]] && (( ${+close_windows_bids[$bid]} )) }; then
            apps_close_windows+=("$app")
        else
            apps_to_quit+=("$app")
        fi
    done

    # Dry-run mode: just show what would happen
    if $DRY_RUN; then
        echo "=== DRY RUN ==="
        echo ""
        echo "Would QUIT (${#apps_to_quit}):"
        for app in "${apps_to_quit[@]}"; do
            echo "  - $app"
        done
        echo ""
        echo "Would CLOSE WINDOWS (${#apps_close_windows}):"
        for app in "${apps_close_windows[@]}"; do
            echo "  - $app"
        done
        echo ""
        echo "Would SLOW-CLOSE (${#apps_slow_close}):"
        for app in "${apps_slow_close[@]}"; do
            echo "  - $app"
        done
        echo ""
        echo "Would SKIP (no-touch):"
        for app in "${apps_skipped[@]}"; do
            echo "  - $app"
        done
        return 0
    fi

    # Quit apps in parallel (don't need focus)
    if (( ${#apps_to_quit} > 0 )); then
        echo "Quitting ${#apps_to_quit} apps in parallel..."
        for app in "${apps_to_quit[@]}"; do
            quit_app "$app" &
        done
        wait
    fi

    # Close windows sequentially (need focus for Cmd+W)
    for app in "${apps_close_windows[@]}"; do
        echo "Closing windows: $app"
        close_app_windows "$app" 3
    done

    # Slow-close apps sequentially with more patience
    for app in "${apps_slow_close[@]}"; do
        echo "Closing windows (slow): $app"
        close_app_windows "$app" 10
    done

    echo ""
    echo "Done."
    (( ${#no_touch_set} > 0 )) && echo "  No-touch: ${(k)no_touch_set}"
    (( ${#close_windows_set} > 0 )) && echo "  Close-windows: ${(k)close_windows_set}"
    (( ${#slow_close_set} > 0 )) && echo "  Slow-close: ${(k)slow_close_set}"
}

main "$@"
