#!/usr/bin/env bash

# Machine Name Script
#
# Outputs the machine name for SSH sessions, used by:
# - config/p10k.zsh (prompt_remote_host)
# - claude/statusline.sh (machine info display)
#
# Output format: "EMOJI NAME" (e.g., "ðŸš€ hetzner-1")
# Outputs nothing if not in SSH session.
# Each machine gets a unique emoji based on its name hash.
#
# Environment variables:
# - SERVER_NAME: Override the machine name entirely
# - MACHINE_EMOJI: Override the emoji (otherwise auto-assigned per machine)
#
# Priority for name resolution:
# 1. $SERVER_NAME env var
# 2. SSH config alias matching public IP
# 3. Abbreviated hostname (truncate if >10 chars)
#
# Uses cached public IPs (~/.cache/public_ip_v4 and v6, 1 hour TTL) to avoid slow network calls.
# Checks both IPv4 and IPv6 addresses against SSH config.

# Exit early if not in SSH session
[[ -z "$SSH_CONNECTION" ]] && exit 0

hostname="${HOST:-$(hostname -s)}"
short_name=""

# Option 1: Use SERVER_NAME env var if set
if [[ -n "$SERVER_NAME" ]]; then
  short_name="$SERVER_NAME"

# Option 2: Parse SSH config to find alias matching public IP (tries both IPv4 and IPv6)
elif [[ -f ~/.ssh/config ]]; then
  cache_dir="${HOME}/.cache"
  mkdir -p "$cache_dir"
  current_time=$(date +%s)

  # Helper: get cached IP if fresh (< 1 hour old)
  get_cached_ip() {
    local cache_file="$1"
    [[ ! -f "$cache_file" ]] && return 1
    # Get file modification time (compatible with both macOS and Linux)
    local file_mtime
    if stat -c %Y "$cache_file" >/dev/null 2>&1; then
      file_mtime=$(stat -c %Y "$cache_file")
    else
      file_mtime=$(stat -f %m "$cache_file" 2>/dev/null || echo 0)
    fi
    local age=$((current_time - file_mtime))
    if [[ "$age" -lt 3600 ]]; then
      cat "$cache_file" 2>/dev/null
      return 0
    fi
    return 1
  }

  # Helper: match IP against SSH config HostName entries
  match_ssh_config() {
    local ip="$1"
    [[ -z "$ip" ]] && return
    awk -v target="$ip" '
      /^Host / {
        h = $2
        # Skip catch-all patterns like "*" or "*.domain.com"
        if (h ~ /^\*/) { host = ""; next }
        # Strip trailing wildcards: "hetzner-8*" -> "hetzner-8"
        gsub(/[*?]+$/, "", h)
        host = h
      }
      /^[[:space:]]*HostName / { if ($2 == target && host != "") print host }
    ' ~/.ssh/config | head -1
  }

  # Get IPv4 (cached or fresh)
  ipv4=$(get_cached_ip "$cache_dir/public_ip_v4")
  if [[ -z "$ipv4" ]]; then
    ipv4=$(timeout 2 curl -4 -s ifconfig.me 2>/dev/null || timeout 2 curl -4 -s icanhazip.com 2>/dev/null)
    [[ -n "$ipv4" ]] && echo "$ipv4" > "$cache_dir/public_ip_v4"
  fi

  # Get IPv6 (cached or fresh)
  ipv6=$(get_cached_ip "$cache_dir/public_ip_v6")
  if [[ -z "$ipv6" ]]; then
    ipv6=$(timeout 2 curl -6 -s ifconfig.me 2>/dev/null || timeout 2 curl -6 -s icanhazip.com 2>/dev/null)
    [[ -n "$ipv6" ]] && echo "$ipv6" > "$cache_dir/public_ip_v6"
  fi

  # Try matching IPv4 first, then IPv6
  short_name=$(match_ssh_config "$ipv4")
  [[ -z "$short_name" ]] && short_name=$(match_ssh_config "$ipv6")
fi

# Fallback: abbreviate long hostnames
if [[ -z "$short_name" ]]; then
  if (( ${#hostname} > 10 )); then
    short_name="${hostname:0:6}.."
  else
    short_name="$hostname"
  fi
fi

# Select emoji per-machine: use explicit override, or hash name into palette
if [[ -n "$MACHINE_EMOJI" ]]; then
  icon="$MACHINE_EMOJI"
else
  local_emojis=(
    "ðŸš€" "ðŸ’»" "ðŸ–¥ï¸" "âš¡" "ðŸ”¥" "ðŸŒŸ" "ðŸŽ¯" "ðŸ§ " "ðŸ›¸" "ðŸŒŠ" "ðŸŽ¨" "ðŸ”®"
    "ðŸ¦Š" "ðŸ™" "ðŸ¦…" "ðŸ‹" "ðŸº" "ðŸ¦ˆ" "ðŸ¦‰" "ðŸ"
    "ðŸŒµ" "ðŸ„" "ðŸŒ¶ï¸" "ðŸŒ»" "ðŸ€" "ðŸŒ´"
    "â›ï¸" "ðŸ”§" "ðŸ§²" "ðŸ’Ž" "ðŸ—¡ï¸" "ðŸ›¡ï¸"
  )
  # Hash the machine name for a stable emoji assignment
  if command -v md5sum >/dev/null 2>&1; then
    hash_val=$(echo -n "$short_name" | md5sum | cut -c1-8)
  elif command -v md5 >/dev/null 2>&1; then
    hash_val=$(echo -n "$short_name" | md5 | cut -c1-8)
  else
    hash_val="0"
  fi
  idx=$(( 16#$hash_val % ${#local_emojis[@]} ))
  icon="${local_emojis[$idx]}"
fi

echo "$icon $short_name"
