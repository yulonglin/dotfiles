#!/usr/bin/env python3
"""claude-context — YAML-driven plugin profiles for Claude Code.

Manages which plugins load per-project via composable profiles defined in
a single profiles.yaml. Auto-discovers installed plugins from
installed_plugins.json (source of truth).

Usage:
    claude-context                       Show current state / apply context.yaml
    claude-context <profile> [profiles]  Apply profiles, persist to context.yaml
    claude-context --list                Show active plugins and available profiles
    claude-context --clean                  Remove project plugin config
    claude-context --help                Show this help
"""

import argparse
import json
import os
import sys
import tempfile

try:
    import yaml
except ImportError:
    sys.exit("pyyaml required: pip install pyyaml")

# --- Constants ---

INSTALLED_PLUGINS = os.path.expanduser("~/.claude/plugins/installed_plugins.json")
PROFILES_PATH = os.path.expanduser("~/.claude/templates/contexts/profiles.yaml")
GLOBAL_SETTINGS = os.path.expanduser("~/.claude/settings.json")
CONTEXT_FILE = ".claude/context.yaml"
TARGET_FILE = ".claude/settings.json"

# ANSI colors
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[0;33m"
BLUE = "\033[0;34m"
CYAN = "\033[0;36m"
BOLD = "\033[1m"
NC = "\033[0m"


# --- Core functions ---


def load_registry():
    """Build registry from installed_plugins.json (source of truth).

    Returns dict mapping short_name -> qualified_id.
    Handles collisions by keeping both with full qualified IDs.
    """
    if not os.path.exists(INSTALLED_PLUGINS):
        sys.exit(f"{RED}installed_plugins.json not found{NC}")
    with open(INSTALLED_PLUGINS) as f:
        data = json.load(f)
    registry = {}
    for qid in data.get("plugins", {}):
        short = qid.split("@")[0]
        if short in registry:
            # Collision: keep both with full qualified IDs
            old_qid = registry.pop(short)
            registry[old_qid] = old_qid
            registry[qid] = qid
        else:
            registry[short] = qid
    return registry


def load_profiles():
    """Parse profiles.yaml -> (base, profiles)."""
    if not os.path.exists(PROFILES_PATH):
        sys.exit(f"{RED}profiles.yaml not found at {PROFILES_PATH}{NC}\n"
                 "Run deploy.sh or create it manually.")
    with open(PROFILES_PATH) as f:
        data = yaml.safe_load(f)
    base = data.get("base", [])
    profiles = data.get("profiles", {})
    return base, profiles


def build_plugins(registry, base, profiles, profile_names, enable=None, disable=None):
    """Build enabledPlugins dict from profiles + overrides.

    Algorithm:
    1. All registry plugins -> false
    2. Enable base plugins
    3. For each profile: enable its plugins
    4. Apply enable/disable overrides
    5. Resolve to qualified IDs
    """
    # Step 1: all false
    state = {name: False for name in registry}

    # Step 2: base
    for name in base:
        if name in state:
            state[name] = True

    # Step 3: profiles
    for pname in profile_names:
        if pname not in profiles:
            sys.exit(f"{RED}Unknown profile: {pname}{NC}\n"
                     f"Available: {', '.join(sorted(profiles.keys()))}")
        for plugin in profiles[pname].get("enable", []):
            if plugin not in state:
                print(f"{YELLOW}Warning: profile '{pname}' references uninstalled plugin: {plugin} (skipped){NC}",
                      file=sys.stderr)
                continue
            state[plugin] = True

    # Step 4: overrides
    for name in (enable or []):
        if name not in state:
            print(f"{YELLOW}Warning: enable references uninstalled plugin: {name} (skipped){NC}",
                  file=sys.stderr)
            continue
        state[name] = True
    for name in (disable or []):
        if name in state:
            state[name] = False

    # Step 5: resolve to qualified IDs
    return {registry[name]: enabled for name, enabled in state.items()}


def apply_to_settings(enabled_plugins):
    """Write enabledPlugins to settings.json, preserving other keys.

    Uses atomic write (temp file + rename).
    """
    existing = {}
    if os.path.exists(TARGET_FILE):
        with open(TARGET_FILE) as f:
            try:
                existing = json.load(f)
            except json.JSONDecodeError:
                pass

    existing["enabledPlugins"] = enabled_plugins

    # Atomic write
    os.makedirs(os.path.dirname(TARGET_FILE) or ".", exist_ok=True)
    dir_name = os.path.dirname(os.path.abspath(TARGET_FILE))
    fd, tmp_path = tempfile.mkstemp(dir=dir_name, suffix=".json")
    try:
        with os.fdopen(fd, "w") as f:
            json.dump(existing, f, indent=2)
            f.write("\n")
        os.rename(tmp_path, TARGET_FILE)
    except Exception:
        os.unlink(tmp_path)
        raise


def write_context_yaml(profile_names, enable=None, disable=None):
    """Write/update .claude/context.yaml."""
    data = {"profiles": profile_names}
    if enable:
        data["enable"] = enable
    if disable:
        data["disable"] = disable

    os.makedirs(os.path.dirname(CONTEXT_FILE) or ".", exist_ok=True)
    with open(CONTEXT_FILE, "w") as f:
        f.write("# .claude/context.yaml — committed, declares project's plugin needs\n")
        yaml.dump(data, f, default_flow_style=False, sort_keys=False)


def load_context_yaml():
    """Load .claude/context.yaml if it exists -> (profiles, enable, disable) or None."""
    if not os.path.exists(CONTEXT_FILE):
        return None
    with open(CONTEXT_FILE) as f:
        data = yaml.safe_load(f)
    if not data:
        return None
    return (
        data.get("profiles", []),
        data.get("enable", []),
        data.get("disable", []),
    )


def check_stale_settings():
    """Warn if project settings.json references plugins with changed qualified IDs."""
    if not os.path.exists(TARGET_FILE):
        return
    with open(TARGET_FILE) as f:
        try:
            project_plugins = json.load(f).get("enabledPlugins", {})
        except json.JSONDecodeError:
            return

    registry = load_registry()
    installed_qids = set(registry.values())

    stale = []
    for qid in project_plugins:
        if qid not in installed_qids:
            short = qid.split("@")[0]
            # Check if same short name exists under different marketplace
            new_qid = registry.get(short)
            if new_qid and new_qid != qid:
                stale.append((qid, new_qid))
            elif not new_qid:
                stale.append((qid, None))  # plugin no longer installed

    if stale:
        print(f"\n{YELLOW}Stale settings detected:{NC}")
        for old, new in stale:
            if new:
                print(f"  {old} → {new}")
            else:
                print(f"  {old} (no longer installed)")
        print(f"{BLUE}Run: claude-context <profile> to refresh{NC}")


# --- Subcommands ---


def show_status():
    """Show current active context and available profiles."""
    # --- Active context ---
    settings_path = TARGET_FILE if os.path.exists(TARGET_FILE) else GLOBAL_SETTINGS
    plugins = {}
    if os.path.exists(settings_path):
        with open(settings_path) as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                data = {}
        plugins = data.get("enabledPlugins", {})

    on = sorted(k.split("@")[0] for k, v in plugins.items() if v)
    off = sorted(k.split("@")[0] for k, v in plugins.items() if not v)

    # Context header
    ctx = load_context_yaml()
    if ctx:
        pnames, enable, disable = ctx
        print(f"{BOLD}Active context:{NC} {BLUE}{', '.join(pnames)}{NC}")
        if enable:
            print(f"  + {', '.join(enable)}")
        if disable:
            print(f"  - {', '.join(disable)}")
    elif os.path.exists(TARGET_FILE):
        print(f"{BOLD}Active context:{NC} {YELLOW}manual{NC} (no context.yaml)")
    else:
        print(f"{BOLD}Active context:{NC} {YELLOW}global defaults{NC}")

    # Plugin status
    print(f"\n{GREEN}ON  ({len(on)}):{NC} {', '.join(on)}")
    if off:
        print(f"{YELLOW}OFF ({len(off)}):{NC} {', '.join(off)}")

    # Warn about missing context.yaml
    if not ctx and os.path.isdir(".claude") and not os.path.exists(CONTEXT_FILE):
        print(f"\n{YELLOW}Warning: this project has .claude/ but no context.yaml{NC}")
        print(f"  Run: claude-context <profile> to set up context")

    # Check for stale settings
    check_stale_settings()

    # --- Available profiles ---
    _, profiles = load_profiles()
    print(f"\n{BOLD}Profiles:{NC}")
    for name, pdata in profiles.items():
        comment = pdata.get("comment", "")
        print(f"  {GREEN}{name:<12}{NC} {comment}")


def apply_profiles_cmd(profile_names):
    """Apply profiles, write settings.json + context.yaml."""
    registry = load_registry()
    base, profiles = load_profiles()

    # Validate
    for pname in profile_names:
        if pname not in profiles:
            sys.exit(f"{RED}Unknown profile: {pname}{NC}\n"
                     f"Available: {', '.join(sorted(profiles.keys()))}")

    enabled = build_plugins(registry, base, profiles, profile_names)
    apply_to_settings(enabled)
    write_context_yaml(profile_names)

    on = sorted(k.split("@")[0] for k, v in enabled.items() if v)
    print(f"{GREEN}Applied:{NC} {', '.join(profile_names)}")
    print(f"{GREEN}Enabled:{NC} {', '.join(on)}")
    print(f"  -> {TARGET_FILE}")
    print(f"  -> {CONTEXT_FILE}")
    print(f"{YELLOW}Restart Claude Code to apply changes.{NC}")


def apply_context_yaml_cmd():
    """Apply existing context.yaml."""
    ctx = load_context_yaml()
    if not ctx:
        sys.exit(f"{YELLOW}No .claude/context.yaml found.{NC}\n"
                 "Usage: claude-context <profile> [profiles]")

    pnames, enable, disable = ctx
    registry = load_registry()
    base, profiles = load_profiles()
    enabled = build_plugins(registry, base, profiles, pnames, enable, disable)
    apply_to_settings(enabled)

    on = sorted(k.split("@")[0] for k, v in enabled.items() if v)
    print(f"{GREEN}Applied from context.yaml:{NC} profiles={pnames}")
    print(f"{GREEN}Enabled:{NC} {', '.join(on)}")
    print(f"  -> {TARGET_FILE}")
    print(f"{YELLOW}Restart Claude Code to apply changes.{NC}")


def reset():
    """Remove enabledPlugins from project settings.json, delete context.yaml."""
    changed = False

    if os.path.exists(CONTEXT_FILE):
        os.remove(CONTEXT_FILE)
        print(f"{GREEN}Removed:{NC} {CONTEXT_FILE}")
        changed = True

    if os.path.exists(TARGET_FILE):
        with open(TARGET_FILE) as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                data = {}

        if "enabledPlugins" in data:
            del data["enabledPlugins"]
            if data:
                with open(TARGET_FILE, "w") as f:
                    json.dump(data, f, indent=2)
                    f.write("\n")
                print(f"{GREEN}Removed enabledPlugins from:{NC} {TARGET_FILE}")
            else:
                os.remove(TARGET_FILE)
                print(f"{GREEN}Removed:{NC} {TARGET_FILE} (was empty after cleanup)")
            changed = True

    if not changed:
        print(f"{YELLOW}Nothing to reset.{NC}")
    else:
        print(f"{YELLOW}Restart Claude Code to apply changes.{NC}")


# --- Main ---


def main():
    parser = argparse.ArgumentParser(
        description="YAML-driven plugin profiles for Claude Code",
        usage="claude-context [<profile> ...] [--list] [--clean]",
        add_help=False,
    )
    parser.add_argument("profiles", nargs="*", help="Profile names to apply")
    parser.add_argument("--list", action="store_true", help="Show active plugins and available profiles")
    parser.add_argument("--clean", "--reset", action="store_true", dest="clean", help="Remove project plugin config")
    parser.add_argument("-h", "--help", action="store_true", help="Show help")

    args = parser.parse_args()

    if args.help:
        print(__doc__)
        try:
            _, profiles = load_profiles()
            print("PROFILES:")
            for name, pdata in profiles.items():
                comment = pdata.get("comment", "")
                plugins = pdata.get("enable", [])
                print(f"    {name:<12} {comment}")
                if plugins:
                    print(f"                 [{', '.join(plugins)}]")
            print()
        except SystemExit:
            pass  # profiles.yaml not found, skip listing
        parser.print_help()
        sys.exit(0)

    if args.list:
        show_status()
    elif args.clean:
        reset()
    elif args.profiles:
        apply_profiles_cmd(args.profiles)
    else:
        # No args: show status, and auto-apply context.yaml if present
        ctx = load_context_yaml()
        if ctx:
            apply_context_yaml_cmd()
        show_status()


if __name__ == "__main__":
    main()
