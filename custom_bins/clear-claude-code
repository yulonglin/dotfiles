#!/usr/bin/env bash
# Clear Claude Code - Kill Claude Code CLI processes
# By default: only YOUR processes, preserves current session & tmux
#
# Usage:
#   clear-claude-code              # Kill your orphaned/stopped/idle processes
#   clear-claude-code --status     # Show your processes (no kill)
#   clear-claude-code --all-users  # Show/kill all users (may need sudo)
#   clear-claude-code --dry-run    # Preview what would be killed
#   clear-claude-code --force      # Also kill active processes
#   clear-claude-code --all        # Kill ALL including current session

set -euo pipefail

# Auto-detect Unicode support (fallback to ASCII for minimal terminals)
if [[ "${LANG:-}" == *UTF* || "${LC_ALL:-}" == *UTF* ]]; then
    LINE="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
else
    LINE="----------------------------------------------------------------------------------------------"
fi

# Idle detection: only kill processes with no output activity for 24h.
IDLE_THRESHOLD_HOURS=24
IDLE_THRESHOLD_SECONDS=$((IDLE_THRESHOLD_HOURS * 3600))

# Stale UNKNOWN process detection: kill if >N days old with no parent activity
STALE_UNKNOWN_DAYS=3
STALE_UNKNOWN_SECONDS=$((STALE_UNKNOWN_DAYS * 86400))

# Parse arguments
DRY_RUN=false
KILL_ALL=false
FORCE=false
STATUS_ONLY=false
SKIP_CONFIRM=false
ALL_USERS=false
TARGET_USER="$(whoami)"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|--preview|-n) DRY_RUN=true ;;
        --all|-a) KILL_ALL=true ;;
        --force|-f) FORCE=true ;;
        --status|--list|-s|-l) STATUS_ONLY=true ;;
        --yes|-y) SKIP_CONFIRM=true ;;
        --all-users|-A) ALL_USERS=true ;;
        --help|-h)
            cat <<EOF
Usage: clear-claude-code [OPTIONS]

Kill Claude Code CLI processes.

By default, only shows/kills YOUR processes (current user: $TARGET_USER).
Tmux sessions are preserved unless --force/--all is used.

Options:
  --list, --status, -l, -s   Show all Claude Code processes (no kill)
  --preview, --dry-run, -n   Show what would be killed without killing
  --force, -f      Also kill ACTIVE processes (requires confirmation)
  --all, -a        Kill ALL processes including current (requires confirmation)
  --all-users, -A  Show/kill processes for ALL users (may require sudo)
  --yes, -y        Skip confirmation prompt (for scripts/automation)
  --help, -h       Show this help message

Status indicators:
  *ACTIVE*        Process in foreground terminal (likely in use)
  tmux            Process belongs to a tmux session (preserved by default)
  idle>=${IDLE_THRESHOLD_HOURS}h  No output activity for ${IDLE_THRESHOLD_HOURS}h
  recent          Output activity within last ${IDLE_THRESHOLD_HOURS}h
  orphaned        Parent process died (ppid=1) - KILLED by default
  zombie_parent   Parent PID doesn't exist (not yet reparented) - KILLED by default
  stopped         Process is stopped/traced (stat=T) - KILLED by default
  stale_unknown   No TTY, living parent, but >${STALE_UNKNOWN_DAYS}d old - KILLED by default
  unknown         No TTY, living parent, <${STALE_UNKNOWN_DAYS}d old (background agent?)
EOF
            exit 0
            ;;
        *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
    shift
done

# --all implies --force
[[ "$KILL_ALL" == "true" ]] && FORCE=true

# Get a single ps field for a PID, with whitespace trimmed
ps_field() {
    ps -p "$1" -o "$2=" 2>/dev/null | tr -d ' ' || echo ""
}

is_in_tmux() {
    local pid="$1"
    while [[ -n "$pid" && "$pid" -gt 1 ]]; do
        local comm=$(ps_field "$pid" "comm")
        [[ "$comm" == *tmux* ]] && return 0
        local ppid=$(ps_field "$pid" "ppid")
        [[ -z "$ppid" || "$ppid" == "$pid" ]] && break
        pid="$ppid"
    done
    return 1
}

get_process_tty() {
    local tty=$(ps_field "$1" "tty")
    [[ -z "$tty" || "$tty" == "?" || "$tty" == "??" ]] && echo "" || echo "$tty"
}

get_parent_chain() {
    local pid="$1" chain="" depth=0 max_depth=4

    while [[ -n "$pid" && "$pid" -gt 1 && $depth -lt $max_depth ]]; do
        local ppid=$(ps_field "$pid" "ppid")
        [[ -z "$ppid" || "$ppid" == "$pid" ]] && break
        local pcomm=$(ps_field "$ppid" "comm")
        local label="${ppid}${pcomm:+:$pcomm}"
        chain="${chain:+$chain<-}$label"
        pid="$ppid"
        ((depth++))
    done

    echo "${chain:--}"
}

get_parent_info() {
    local pid="$1"
    local ppid=$(ps_field "$pid" "ppid")
    [[ -z "$ppid" ]] && { echo "-"; return; }
    local pcomm=$(ps_field "$ppid" "comm")
    echo "${ppid}${pcomm:+:$pcomm}"
}

get_tty_mtime() {
    local tty_path="/dev/$1"
    [[ -e "$tty_path" ]] || { echo ""; return; }
    if [[ "$(uname -s)" == "Darwin" ]]; then
        stat -f %m "$tty_path" 2>/dev/null || echo ""
    else
        stat -c %Y "$tty_path" 2>/dev/null || echo ""
    fi
}

# Check if a process is older than threshold (in seconds)
is_process_old() {
    local pid="$1"
    local threshold_seconds="$2"

    # Try to get elapsed time from ps etime field
    local etime=$(ps -p "$pid" -o etime= 2>/dev/null | tr -d ' ')
    [[ -z "$etime" ]] && return 1

    # Parse etime format: [[DD-]HH:]MM:SS
    local total_seconds=0
    if [[ "$etime" =~ ^([0-9]+)-([0-9]+):([0-9]+):([0-9]+)$ ]]; then
        # DD-HH:MM:SS
        total_seconds=$(( ${BASH_REMATCH[1]} * 86400 + ${BASH_REMATCH[2]} * 3600 + ${BASH_REMATCH[3]} * 60 + ${BASH_REMATCH[4]} ))
    elif [[ "$etime" =~ ^([0-9]+):([0-9]+):([0-9]+)$ ]]; then
        # HH:MM:SS
        total_seconds=$(( ${BASH_REMATCH[1]} * 3600 + ${BASH_REMATCH[2]} * 60 + ${BASH_REMATCH[3]} ))
    elif [[ "$etime" =~ ^([0-9]+):([0-9]+)$ ]]; then
        # MM:SS
        total_seconds=$(( ${BASH_REMATCH[1]} * 60 + ${BASH_REMATCH[2]} ))
    fi

    (( total_seconds >= threshold_seconds ))
}

# Get process status: ACTIVE, TMUX, ORPHANED, ZOMBIE_PARENT, STOPPED, IDLE, RECENT, STALE_UNKNOWN, or UNKNOWN
# This is the main status function - combines all checks efficiently
get_process_status() {
    local pid="$1"

    # Check tmux ancestry first (requires walking parent chain)
    is_in_tmux "$pid" && { echo "TMUX"; return; }

    # Get stat and ppid in one call where possible
    local stat=$(ps_field "$pid" "stat")
    local ppid=$(ps_field "$pid" "ppid")

    # Foreground process (+ in stat)
    [[ "$stat" == *"+"* ]] && { echo "ACTIVE"; return; }

    # Stopped process (T in stat)
    [[ "$stat" == *"T"* ]] && { echo "STOPPED"; return; }

    # Orphaned process (adopted by init)
    [[ "$ppid" == "1" ]] && { echo "ORPHANED"; return; }

    # Zombie parent: ppid exists but parent process doesn't (not yet reparented to init)
    if [[ -n "$ppid" && "$ppid" != "1" ]]; then
        if ! ps -p "$ppid" >/dev/null 2>&1; then
            echo "ZOMBIE_PARENT"
            return
        fi
    fi

    # Check TTY activity for idle detection
    local tty=$(get_process_tty "$pid")
    if [[ -z "$tty" ]]; then
        # No TTY: check if process is stale (UNKNOWN + too old)
        if is_process_old "$pid" "$STALE_UNKNOWN_SECONDS"; then
            echo "STALE_UNKNOWN"
            return
        else
            echo "UNKNOWN"
            return
        fi
    fi

    local last=$(get_tty_mtime "$tty")
    [[ -z "$last" ]] && { echo "UNKNOWN"; return; }

    local now=$(date +%s)
    (( (now - last) >= IDLE_THRESHOLD_SECONDS )) && echo "IDLE" || echo "RECENT"
}

# Convert internal status to display label
status_label() {
    case "$1" in
        ACTIVE)          echo "*ACTIVE*" ;;
        TMUX)            echo "tmux" ;;
        IDLE)            echo "idle>=${IDLE_THRESHOLD_HOURS}h" ;;
        RECENT)          echo "recent" ;;
        ORPHANED)        echo "orphaned" ;;
        ZOMBIE_PARENT)   echo "zombie_parent" ;;
        STOPPED)         echo "stopped" ;;
        STALE_UNKNOWN)   echo "stale_unknown" ;;
        *)               echo "unknown" ;;
    esac
}

# Get claude PIDs based on ALL_USERS setting
get_claude_pids() {
    if [[ "$ALL_USERS" == "true" ]]; then
        ps aux | awk '($11 ~ /\/claude$/ || $11 == "claude") {print $2}'
    else
        ps aux | awk -v user="$TARGET_USER" '($1 == user && ($11 ~ /\/claude$/ || $11 == "claude")) {print $2}'
    fi
}

# Get full ps aux line for claude processes (for detailed display)
get_claude_ps_lines() {
    if [[ "$ALL_USERS" == "true" ]]; then
        ps aux | awk '$11 ~ /\/claude$/ || $11 == "claude"'
    else
        ps aux | awk -v user="$TARGET_USER" '$1 == user && ($11 ~ /\/claude$/ || $11 == "claude")'
    fi
}

# Show detailed status of all Claude Code processes
show_status() {
    local scope="user: $TARGET_USER"
    [[ "$ALL_USERS" == "true" ]] && scope="all users"
    echo "Claude Code Processes ($scope):"
    echo "$LINE"
    printf "%-8s %-12s %-18s %-10s %-6s %-6s %s\n" "PID" "STATUS" "PARENT" "UPTIME" "CPU%" "MEM%" "COMMAND"
    echo "$LINE"

    # Counters as associative-style with simple variables
    local count=0 active_count=0 tmux_count=0 idle_count=0 recent_count=0
    local orphaned_count=0 zombie_parent_count=0 stopped_count=0 stale_unknown_count=0 unknown_count=0
    local unknown_pids=() zombie_parent_pids=()

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local pid=$(echo "$line" | awk '{print $2}')
        local cpu=$(echo "$line" | awk '{print $3}')
        local mem=$(echo "$line" | awk '{print $4}')
        local etime=$(ps_field "$pid" "etime")
        local parent=$(get_parent_info "$pid" | cut -c1-18)
        local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf $i" "; print ""}' | cut -c1-40)
        local proc_status=$(get_process_status "$pid")

        ((count++)) || true

        # Increment appropriate counter
        case "$proc_status" in
            ACTIVE)          ((active_count++)) || true ;;
            TMUX)            ((tmux_count++)) || true ;;
            IDLE)            ((idle_count++)) || true ;;
            RECENT)          ((recent_count++)) || true ;;
            ORPHANED)        ((orphaned_count++)) || true ;;
            ZOMBIE_PARENT)   ((zombie_parent_count++)) || true; zombie_parent_pids+=("$pid") ;;
            STOPPED)         ((stopped_count++)) || true ;;
            STALE_UNKNOWN)   ((stale_unknown_count++)) || true ;;
            *)               ((unknown_count++)) || true; unknown_pids+=("$pid") ;;
        esac

        printf "%-8s %-12s %-18s %-10s %-6s %-6s %s\n" \
            "$pid" "$(status_label "$proc_status")" "$parent" "${etime:-?}" "$cpu" "$mem" "$cmd"
    done < <(get_claude_ps_lines)

    echo "$LINE"
    echo "Total: $count process(es) | active: $active_count, tmux: $tmux_count, idle: $idle_count, recent: $recent_count, orphaned: $orphaned_count, zombie_parent: $zombie_parent_count, stopped: $stopped_count, stale_unknown: $stale_unknown_count, unknown: $unknown_count"

    # Status-specific notes
    [[ $active_count -gt 0 ]] && echo -e "\nâš ï¸  Warning: $active_count process(es) appear to be in active use.\n   Use --dry-run to preview before killing."
    [[ $tmux_count -gt 0 ]] && echo -e "\nNote: tmux sessions are preserved by default."
    [[ $((orphaned_count + zombie_parent_count + stopped_count + stale_unknown_count)) -gt 0 ]] && echo -e "\nðŸ’€ $((orphaned_count + zombie_parent_count + stopped_count + stale_unknown_count)) stale/orphaned/zombie process(es) will be killed by default."

    if [[ ${#zombie_parent_pids[@]} -gt 0 ]]; then
        echo -e "\nZombie parent processes (parent no longer exists):"
        for pid in "${zombie_parent_pids[@]}"; do
            local ppid=$(ps_field "$pid" "ppid")
            local etime=$(ps_field "$pid" "etime")
            echo "  PID $pid | ppid $ppid (dead) | uptime $etime"
        done
    fi

    if [[ $unknown_count -gt 0 ]]; then
        echo -e "\nRecent background processes (preserved by default):"
        for pid in "${unknown_pids[@]}"; do
            local tty=$(get_process_tty "$pid")
            local stat=$(ps_field "$pid" "stat")
            local chain=$(get_parent_chain "$pid")
            echo "  PID $pid | tty ${tty:-?} | stat ${stat:-?} | parent $chain"
        done
    fi
}

# Handle --status mode
if [[ "$STATUS_ONLY" == "true" ]]; then
    show_status
    exit 0
fi

# Find current session's PID (the claude process running in current terminal)
CURRENT_PID="${CLAUDE_CODE_PID:-}"
if [[ -z "$CURRENT_PID" ]]; then
    CURRENT_TTY=$(tty 2>/dev/null | sed 's|/dev/||' || echo "")
    [[ -n "$CURRENT_TTY" ]] && CURRENT_PID=$(ps -t "$CURRENT_TTY" -o pid,comm 2>/dev/null | awk '/claude/ {print $1; exit}' || echo "")
fi

# Count and list processes
PIDS=($(get_claude_pids))
TOTAL=${#PIDS[@]}

if [[ $TOTAL -eq 0 ]]; then
    if [[ "$ALL_USERS" == "true" ]]; then
        echo "No Claude Code processes found."
    else
        echo "No Claude Code processes found for user $TARGET_USER. Use --all-users to see all."
    fi
    exit 0
fi

# Filter processes based on flags
PIDS_TO_KILL=()
SKIPPED_CURRENT=false
# Counters (simple vars for bash 3.2 compatibility)
SKIPPED_ACTIVE=0 SKIPPED_TMUX=0 SKIPPED_RECENT=0 SKIPPED_UNKNOWN=0
KILLING_ORPHANED=0 KILLING_ZOMBIE_PARENT=0 KILLING_STOPPED=0 KILLING_IDLE=0 KILLING_STALE_UNKNOWN=0
KILLING_ACTIVE=0 KILLING_TMUX=0 KILLING_RECENT=0 KILLING_UNKNOWN=0

for pid in "${PIDS[@]}"; do
    # Skip current session unless --all
    if [[ "$KILL_ALL" == "false" && -n "$CURRENT_PID" && "$pid" == "$CURRENT_PID" ]]; then
        SKIPPED_CURRENT=true
        continue
    fi

    proc_status=$(get_process_status "$pid")

    # Skip active processes unless --force
    if [[ "$FORCE" == "false" ]]; then
        case "$proc_status" in
            ACTIVE)   ((SKIPPED_ACTIVE++))   || true; continue ;;
            TMUX)     ((SKIPPED_TMUX++))     || true; continue ;;
            RECENT)   ((SKIPPED_RECENT++))   || true; continue ;;
            UNKNOWN)  ((SKIPPED_UNKNOWN++))  || true; continue ;;
        esac
    fi

    # Always kill: orphaned, zombie parent, stopped, idle, stale unknown
    # Preserve by default: active, tmux, recent, unknown
    # Track what we're killing for messaging (all statuses)
    case "$proc_status" in
        ORPHANED)       ((KILLING_ORPHANED++))       || true ;;
        ZOMBIE_PARENT)  ((KILLING_ZOMBIE_PARENT++))  || true ;;
        STOPPED)        ((KILLING_STOPPED++))        || true ;;
        IDLE)           ((KILLING_IDLE++))           || true ;;
        STALE_UNKNOWN)  ((KILLING_STALE_UNKNOWN++))  || true ;;
        ACTIVE)         ((KILLING_ACTIVE++))         || true ;;
        TMUX)           ((KILLING_TMUX++))           || true ;;
        RECENT)         ((KILLING_RECENT++))         || true ;;
        *)              ((KILLING_UNKNOWN++))        || true ;;
    esac

    PIDS_TO_KILL+=("$pid")
done

KILL_COUNT=${#PIDS_TO_KILL[@]}

# Helper to build parenthetical skip messages
build_skip_msg() {
    local msg=""
    [[ "$SKIPPED_CURRENT" == "true" ]] && msg="$msg (current session preserved)"
    [[ $SKIPPED_ACTIVE -gt 0 ]] && msg="$msg ($SKIPPED_ACTIVE active preserved, use --force to kill)"
    [[ $SKIPPED_TMUX -gt 0 ]] && msg="$msg ($SKIPPED_TMUX tmux preserved)"
    [[ $SKIPPED_RECENT -gt 0 ]] && msg="$msg ($SKIPPED_RECENT recent output preserved)"
    [[ $SKIPPED_UNKNOWN -gt 0 ]] && msg="$msg ($SKIPPED_UNKNOWN background agents preserved)"
    echo "$msg"
}

if [[ $KILL_COUNT -eq 0 ]]; then
    echo "No Claude Code processes to kill$(build_skip_msg)"
    exit 0
fi

# Show what we're doing
echo "Found $TOTAL Claude Code process(es)"
[[ "$SKIPPED_CURRENT" == "true" ]] && echo "  Preserving current session (PID $CURRENT_PID)"
[[ $SKIPPED_ACTIVE -gt 0 ]] && echo "  Preserving $SKIPPED_ACTIVE active process(es)"
[[ $SKIPPED_TMUX -gt 0 ]] && echo "  Preserving $SKIPPED_TMUX tmux process(es)"
[[ $SKIPPED_RECENT -gt 0 ]] && echo "  Preserving $SKIPPED_RECENT process(es) with recent output"
[[ $SKIPPED_UNKNOWN -gt 0 ]] && echo "  Preserving $SKIPPED_UNKNOWN background process(es) with living parent"

# Build descriptive message for what we're killing
parts=()
[[ $KILLING_ORPHANED -gt 0 ]] && parts+=("$KILLING_ORPHANED orphaned")
[[ $KILLING_ZOMBIE_PARENT -gt 0 ]] && parts+=("$KILLING_ZOMBIE_PARENT zombie_parent")
[[ $KILLING_STOPPED -gt 0 ]] && parts+=("$KILLING_STOPPED stopped")
[[ $KILLING_IDLE -gt 0 ]] && parts+=("$KILLING_IDLE idle>=${IDLE_THRESHOLD_HOURS}h")
[[ $KILLING_STALE_UNKNOWN -gt 0 ]] && parts+=("$KILLING_STALE_UNKNOWN stale_unknown")
[[ $KILLING_ACTIVE -gt 0 ]] && parts+=("$KILLING_ACTIVE active")
[[ $KILLING_TMUX -gt 0 ]] && parts+=("$KILLING_TMUX tmux")
[[ $KILLING_RECENT -gt 0 ]] && parts+=("$KILLING_RECENT recent")
[[ $KILLING_UNKNOWN -gt 0 ]] && parts+=("$KILLING_UNKNOWN unknown")

if [[ "$KILL_ALL" == "true" ]]; then
    echo "  Will kill $KILL_COUNT process(es) including current session..."
elif [[ ${#parts[@]} -gt 0 ]]; then
    IFS=" + "; echo "  Killing $KILL_COUNT process(es): ${parts[*]}"; unset IFS
else
    echo "  Killing $KILL_COUNT process(es)"
fi

# Require confirmation for --force or --all (unless --yes or --dry-run)
if [[ "$DRY_RUN" == "false" && "$SKIP_CONFIRM" == "false" && ("$FORCE" == "true" || "$KILL_ALL" == "true") ]]; then
    echo ""
    if [[ "$KILL_ALL" == "true" ]]; then
        echo "âš ï¸  This will kill ALL Claude Code processes including the current session!"
    else
        echo "âš ï¸  This will kill active Claude Code processes!"
    fi
    printf "Continue? [y/N] "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

if [[ "$DRY_RUN" == "true" ]]; then
    echo ""
    echo "[DRY RUN] Would kill PIDs: ${PIDS_TO_KILL[*]}"
    echo ""
    echo "Process details:"
    for pid in "${PIDS_TO_KILL[@]}"; do
        ps -p "$pid" -o pid,etime,command 2>/dev/null | tail -1 || echo "  $pid (already terminated)"
    done
else
    # Kill the processes with escalation: SIGTERM -> wait -> SIGKILL
    killed=0
    failed_pids=()
    stubborn_pids=()

    # First pass: SIGTERM
    for pid in "${PIDS_TO_KILL[@]}"; do
        kill "$pid" 2>/dev/null || true
    done

    # Brief wait for graceful shutdown
    sleep 0.5

    # Second pass: check survivors, SIGKILL stubborn ones
    for pid in "${PIDS_TO_KILL[@]}"; do
        if ps -p "$pid" >/dev/null 2>&1; then
            # Still alive, use SIGKILL
            stubborn_pids+=("$pid")
            if kill -9 "$pid" 2>/dev/null; then
                ((killed++))
            else
                failed_pids+=("$pid")
            fi
        else
            ((killed++))
        fi
    done

    if [[ $killed -gt 0 ]]; then
        msg="Done. Killed $killed Claude Code process(es)."
        [[ ${#stubborn_pids[@]} -gt 0 ]] && msg="$msg (${#stubborn_pids[@]} required SIGKILL)"
        echo "$msg"
    fi

    if [[ ${#failed_pids[@]} -gt 0 ]]; then
        echo "Failed to kill ${#failed_pids[@]} process(es): ${failed_pids[*]}"
        # Check if they're root-owned or other user
        for pid in "${failed_pids[@]}"; do
            owner=$(ps -p "$pid" -o user= 2>/dev/null || echo "unknown")
            if [[ "$owner" != "$TARGET_USER" ]]; then
                echo "  PID $pid is owned by $owner - try: sudo kill -9 $pid"
            fi
        done
    fi
fi

exit 0
