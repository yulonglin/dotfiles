#!/usr/bin/env bash
# Clear Claude Code - Kill Claude Code CLI processes
# Preserves the current session (if running from within Claude Code)
# Preserves tmux sessions and recent-output processes by default
#
# Usage:
#   clear-claude-code              # Kill all claude processes except current
#   clear-claude-code --all        # Kill ALL claude processes (including current)
#   clear-claude-code --dry-run    # Show what would be killed without killing

set -euo pipefail

# Auto-detect Unicode support (fallback to ASCII for minimal terminals)
if [[ "${LANG:-}" == *UTF* || "${LC_ALL:-}" == *UTF* ]]; then
    LINE="──────────────────────────────────────────────────────────────────────────────────────────────"
else
    LINE="----------------------------------------------------------------------------------------------"
fi

# Idle detection: only kill processes with no output activity for 24h.
IDLE_THRESHOLD_HOURS=24
IDLE_THRESHOLD_SECONDS=$((IDLE_THRESHOLD_HOURS * 3600))

# Parse arguments
DRY_RUN=false
KILL_ALL=false
FORCE=false
STATUS_ONLY=false
SKIP_CONFIRM=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --dry-run|--preview|-n)
            DRY_RUN=true
            shift
            ;;
        --all|-a)
            KILL_ALL=true
            shift
            ;;
        --force|-f)
            FORCE=true
            shift
            ;;
        --status|--list|-s|-l)
            STATUS_ONLY=true
            shift
            ;;
        --yes|-y)
            SKIP_CONFIRM=true
            shift
            ;;
        --help|-h)
            echo "Usage: clear-claude-code [OPTIONS]"
            echo ""
            echo "Kill Claude Code CLI processes."
            echo ""
            echo "By default, only kills processes with no output activity for ${IDLE_THRESHOLD_HOURS}h."
            echo "Tmux sessions are preserved unless --force/--all is used."
            echo ""
            echo "Options:"
            echo "  --list, --status, -l, -s   Show all Claude Code processes (no kill)"
            echo "  --preview, --dry-run, -n   Show what would be killed without killing"
            echo "  --force, -f      Also kill ACTIVE processes (requires confirmation)"
            echo "  --all, -a        Kill ALL processes including current (requires confirmation)"
            echo "  --yes, -y        Skip confirmation prompt (for scripts/automation)"
            echo "  --help, -h       Show this help message"
            echo ""
            echo "Status indicators:"
            echo "  *ACTIVE*        Process in foreground terminal (likely in use)"
            echo "  tmux            Process belongs to a tmux session (preserved by default)"
            echo "  idle>=${IDLE_THRESHOLD_HOURS}h  No output activity for ${IDLE_THRESHOLD_HOURS}h"
            echo "  recent          Output activity within last ${IDLE_THRESHOLD_HOURS}h"
            echo "  unknown         Output activity could not be determined"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# --all implies --force
[[ "$KILL_ALL" == "true" ]] && FORCE=true

is_in_tmux() {
    local pid="$1"
    while [[ -n "$pid" && "$pid" -gt 1 ]]; do
        local comm=$(ps -p "$pid" -o comm= 2>/dev/null | tr -d ' ' || echo "")
        if [[ "$comm" == *tmux* ]]; then
            return 0
        fi
        local ppid=$(ps -p "$pid" -o ppid= 2>/dev/null | tr -d ' ' || echo "")
        [[ -z "$ppid" || "$ppid" == "$pid" ]] && break
        pid="$ppid"
    done
    return 1
}

get_process_tty() {
    local tty=$(ps -p "$1" -o tty= 2>/dev/null | tr -d ' ' || echo "")
    if [[ -z "$tty" || "$tty" == "?" || "$tty" == "??" ]]; then
        echo ""
    else
        echo "$tty"
    fi
}

get_parent_chain() {
    local pid="$1"
    local chain=""
    local depth=0
    local max_depth=4

    while [[ -n "$pid" && "$pid" -gt 1 && $depth -lt $max_depth ]]; do
        local ppid=$(ps -p "$pid" -o ppid= 2>/dev/null | tr -d ' ' || echo "")
        [[ -z "$ppid" || "$ppid" == "$pid" ]] && break
        local pcomm=$(ps -p "$ppid" -o comm= 2>/dev/null | tr -d ' ' || echo "")
        local label="$ppid"
        [[ -n "$pcomm" ]] && label="${ppid}:${pcomm}"
        if [[ -z "$chain" ]]; then
            chain="$label"
        else
            chain="${chain}<-${label}"
        fi
        pid="$ppid"
        ((depth++))
    done

    if [[ -z "$chain" ]]; then
        echo "-"
    else
        echo "$chain"
    fi
}

get_parent_info() {
    local pid="$1"
    local ppid=$(ps -p "$pid" -o ppid= 2>/dev/null | tr -d ' ' || echo "")
    [[ -z "$ppid" ]] && { echo "-"; return; }

    local pcomm=$(ps -p "$ppid" -o comm= 2>/dev/null | tr -d ' ' || echo "")
    if [[ -n "$pcomm" ]]; then
        echo "${ppid}:${pcomm}"
    else
        echo "$ppid"
    fi
}

get_tty_mtime() {
    local tty="$1"
    local tty_path="/dev/$tty"
    [[ -e "$tty_path" ]] || { echo ""; return; }
    if [[ "$(uname -s)" == "Darwin" ]]; then
        stat -f %m "$tty_path" 2>/dev/null || echo ""
    else
        stat -c %Y "$tty_path" 2>/dev/null || echo ""
    fi
}

get_output_status() {
    local pid="$1"
    local tty
    tty=$(get_process_tty "$pid")
    [[ -z "$tty" ]] && { echo "UNKNOWN"; return; }

    local last
    last=$(get_tty_mtime "$tty")
    [[ -z "$last" ]] && { echo "UNKNOWN"; return; }

    local now
    now=$(date +%s)
    local delta=$((now - last))
    if (( delta >= IDLE_THRESHOLD_SECONDS )); then
        echo "IDLE"
    else
        echo "RECENT"
    fi
}

# Check if a process appears to be actively in use
# Returns: ACTIVE, TMUX, IDLE, RECENT, or UNKNOWN
get_process_status() {
    local pid="$1"

    if is_in_tmux "$pid"; then
        echo "TMUX"
        return
    fi

    local stat
    stat=$(ps -p "$pid" -o stat= 2>/dev/null || echo "")
    # S+ means stopped in foreground, R+ means running in foreground
    if [[ "$stat" == *"+"* ]]; then
        echo "ACTIVE"
        return
    fi

    get_output_status "$pid"
}

# Show detailed status of all Claude Code processes
show_status() {
    echo "Claude Code Processes:"
    echo "$LINE"
    printf "%-8s %-12s %-18s %-10s %-6s %-6s %s\n" "PID" "STATUS" "PARENT" "UPTIME" "CPU%" "MEM%" "COMMAND"
    echo "$LINE"

    local count=0
    local active_count=0
    local tmux_count=0
    local idle_count=0
    local recent_count=0
    local unknown_count=0
    local unknown_pids=()

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local pid=$(echo "$line" | awk '{print $2}')
        local cpu=$(echo "$line" | awk '{print $3}')
        local mem=$(echo "$line" | awk '{print $4}')
        local etime=$(ps -p "$pid" -o etime= 2>/dev/null | tr -d ' ' || echo "?")
        local parent=$(get_parent_info "$pid" | cut -c1-18)
        local cmd=$(echo "$line" | awk '{for(i=11;i<=NF;i++) printf $i" "; print ""}' | cut -c1-40)
        local proc_status=$(get_process_status "$pid")

        ((count++)) || true

        local label="unknown"
        case "$proc_status" in
            ACTIVE)
                label="*ACTIVE*"
                ((active_count++)) || true
                ;;
            TMUX)
                label="tmux"
                ((tmux_count++)) || true
                ;;
            IDLE)
                label="idle>=${IDLE_THRESHOLD_HOURS}h"
                ((idle_count++)) || true
                ;;
            RECENT)
                label="recent"
                ((recent_count++)) || true
                ;;
            *)
                ((unknown_count++)) || true
                unknown_pids+=("$pid")
                ;;
        esac

        printf "%-8s %-12s %-18s %-10s %-6s %-6s %s\n" "$pid" "$label" "$parent" "$etime" "$cpu" "$mem" "$cmd"
    done < <(ps aux | awk '$11 ~ /\/claude$/ || $11 == "claude"')

    echo "$LINE"
    echo "Total: $count process(es) | active: $active_count, tmux: $tmux_count, idle>=${IDLE_THRESHOLD_HOURS}h: $idle_count, recent: $recent_count, unknown: $unknown_count"

    if [[ $active_count -gt 0 ]]; then
        echo ""
        echo "⚠️  Warning: $active_count process(es) appear to be in active use."
        echo "   Use --dry-run to preview before killing."
    fi

    if [[ $tmux_count -gt 0 ]]; then
        echo ""
        echo "Note: tmux sessions are preserved by default."
    fi

    if [[ $unknown_count -gt 0 ]]; then
        echo ""
        echo "Unknown details:"
        for pid in "${unknown_pids[@]}"; do
            local tty=$(get_process_tty "$pid")
            local stat=$(ps -p "$pid" -o stat= 2>/dev/null | tr -d ' ' || echo "")
            local chain=$(get_parent_chain "$pid")
            [[ -z "$tty" ]] && tty="?"
            [[ -z "$stat" ]] && stat="?"
            echo "  PID $pid | tty $tty | stat $stat | parent $chain"
        done
    fi
}

# Handle --status mode
if [[ "$STATUS_ONLY" == "true" ]]; then
    show_status
    exit 0
fi

# Find current session's PID (the claude process running in current terminal)
# This is the parent claude process if we're being called from within Claude Code
CURRENT_PID=""
if [[ -n "${CLAUDE_CODE_PID:-}" ]]; then
    CURRENT_PID="$CLAUDE_CODE_PID"
else
    # Try to find the claude process in the current terminal
    CURRENT_TTY=$(tty 2>/dev/null | sed 's|/dev/||' || echo "")
    if [[ -n "$CURRENT_TTY" ]]; then
        CURRENT_PID=$(ps -t "$CURRENT_TTY" -o pid,comm 2>/dev/null | awk '/claude/ {print $1; exit}' || echo "")
    fi
fi

# Get all claude CLI processes (exclude Claude.app and this script)
# Get PIDs where command is exactly 'claude' binary (not Claude.app or subshells)
get_claude_pids() {
    ps aux | awk '($11 ~ /\/claude$/ || $11 == "claude") {print $2}'
}

# Count and list processes
PIDS=($(get_claude_pids))
TOTAL=${#PIDS[@]}

if [[ $TOTAL -eq 0 ]]; then
    echo "No Claude Code processes found."
    exit 0
fi

# Filter processes based on flags
PIDS_TO_KILL=()
SKIPPED_CURRENT=false
SKIPPED_ACTIVE=0
SKIPPED_TMUX=0
SKIPPED_RECENT=0
SKIPPED_UNKNOWN=0

for pid in "${PIDS[@]}"; do
    # Skip current session unless --all
    if [[ "$KILL_ALL" == "false" && -n "$CURRENT_PID" && "$pid" == "$CURRENT_PID" ]]; then
        SKIPPED_CURRENT=true
        continue
    fi

    # Skip active processes unless --force
    if [[ "$FORCE" == "false" ]]; then
        proc_status=$(get_process_status "$pid")
        case "$proc_status" in
            ACTIVE)
                ((SKIPPED_ACTIVE++)) || true
                continue
                ;;
            TMUX)
                ((SKIPPED_TMUX++)) || true
                continue
                ;;
            RECENT)
                ((SKIPPED_RECENT++)) || true
                continue
                ;;
            UNKNOWN)
                ((SKIPPED_UNKNOWN++)) || true
                continue
                ;;
        esac
    fi

    PIDS_TO_KILL+=("$pid")
done

KILL_COUNT=${#PIDS_TO_KILL[@]}

if [[ $KILL_COUNT -eq 0 ]]; then
    msg="No Claude Code processes to kill"
    [[ "$SKIPPED_CURRENT" == "true" ]] && msg="$msg (current session preserved)"
    [[ $SKIPPED_ACTIVE -gt 0 ]] && msg="$msg ($SKIPPED_ACTIVE active preserved, use --force to kill)"
    [[ $SKIPPED_TMUX -gt 0 ]] && msg="$msg ($SKIPPED_TMUX tmux preserved)"
    [[ $SKIPPED_RECENT -gt 0 ]] && msg="$msg ($SKIPPED_RECENT recent output preserved)"
    [[ $SKIPPED_UNKNOWN -gt 0 ]] && msg="$msg ($SKIPPED_UNKNOWN unknown activity preserved)"
    echo "$msg"
    exit 0
fi

# Show what we're doing
echo "Found $TOTAL Claude Code process(es)"
[[ "$SKIPPED_CURRENT" == "true" ]] && echo "  Preserving current session (PID $CURRENT_PID)"
[[ $SKIPPED_ACTIVE -gt 0 ]] && echo "  Preserving $SKIPPED_ACTIVE active process(es)"
[[ $SKIPPED_TMUX -gt 0 ]] && echo "  Preserving $SKIPPED_TMUX tmux process(es)"
[[ $SKIPPED_RECENT -gt 0 ]] && echo "  Preserving $SKIPPED_RECENT process(es) with recent output"
[[ $SKIPPED_UNKNOWN -gt 0 ]] && echo "  Preserving $SKIPPED_UNKNOWN process(es) with unknown activity"

# Determine what we're killing for the message
if [[ "$KILL_ALL" == "true" ]]; then
    echo "  Will kill $KILL_COUNT process(es) including current session..."
elif [[ "$FORCE" == "true" ]]; then
    echo "  Will kill $KILL_COUNT process(es) including active..."
else
    echo "  Killing $KILL_COUNT idle>=${IDLE_THRESHOLD_HOURS}h process(es)..."
fi

# Require confirmation for --force or --all (unless --yes or --dry-run)
if [[ "$DRY_RUN" == "false" && "$SKIP_CONFIRM" == "false" && ("$FORCE" == "true" || "$KILL_ALL" == "true") ]]; then
    echo ""
    if [[ "$KILL_ALL" == "true" ]]; then
        echo "⚠️  This will kill ALL Claude Code processes including the current session!"
    else
        echo "⚠️  This will kill active Claude Code processes!"
    fi
    printf "Continue? [y/N] "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

if [[ "$DRY_RUN" == "true" ]]; then
    echo ""
    echo "[DRY RUN] Would kill PIDs: ${PIDS_TO_KILL[*]}"
    echo ""
    echo "Process details:"
    for pid in "${PIDS_TO_KILL[@]}"; do
        ps -p "$pid" -o pid,etime,command 2>/dev/null | tail -1 || echo "  $pid (already terminated)"
    done
else
    # Kill the processes, tracking success/failure
    killed=0
    failed_pids=()
    for pid in "${PIDS_TO_KILL[@]}"; do
        if kill "$pid" 2>/dev/null; then
            ((killed++))
        else
            failed_pids+=("$pid")
        fi
    done

    if [[ $killed -gt 0 ]]; then
        echo "Done. Killed $killed Claude Code process(es)."
    fi

    if [[ ${#failed_pids[@]} -gt 0 ]]; then
        echo "Failed to kill ${#failed_pids[@]} process(es): ${failed_pids[*]}"
        # Check if they're root-owned
        for pid in "${failed_pids[@]}"; do
            owner=$(ps -p "$pid" -o user= 2>/dev/null || echo "unknown")
            if [[ "$owner" == "root" ]]; then
                echo "  PID $pid is owned by root - try: sudo kill $pid"
            fi
        done
    fi
fi

exit 0
